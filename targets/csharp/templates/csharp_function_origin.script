## ===== check have object parameter and is generator class
#set $have_class_parameter=$ret_type.is_object and $generator.type_is_class($ret_type)
#if $min_args > 0
    #set $length = len($arguments)
    #set $index = 0
    #for $arg in $arguments
        #if $arg.is_object and $generator.type_is_class($arg)
            #set $have_class_parameter=True
            #break
        #end if
    #end for
#end if
#if $have_class_parameter
## ===== check is interface
#if $is_interface 
    $generator.csharp_typename_from_native($ret_type) ${generator.script_function_name_format($func_name)}(#slurp
    ## ===== include parameters
    #include os.path.join($generator.target,"templates","csharp_function_param_origin.script")
);
    #stop
#end if
## ===== function name
    ${generator.parse_class_function_template_file("csharp_function_name_origin.script",$current_class,$current_func)}#slurp
## ===== parameters 
    #include os.path.join($generator.target,"templates","csharp_function_param_origin.script")
)
    {
## ===== call function
    #if str($ret_type) != "void"
        return Internal.${func_name}(#slurp
    #else
        #if $is_constructor
        __Instance=Internal.ctor(#slurp
        #else
        Internal.${func_name}(#slurp
        #end if
    #end if
## ===== instance parameter
    #if not $static and not $is_constructor
__Instance#slurp
        #if $min_args > 0
,#slurp
        #end if
    #end if
    #if $min_args > 0
        #set $index = 0
        #for $arg in $arguments
            #if $arg.is_object and $generator.type_is_class($arg)
${argumtntTips[$index]}.__Instance#slurp
            #else
${argumtntTips[$index]}#slurp
            #end if
            #if $index < $length - 1 
,#slurp
            #end if
            #set $index = $index + 1
        #end for
    #end if
);
    }
#end if

